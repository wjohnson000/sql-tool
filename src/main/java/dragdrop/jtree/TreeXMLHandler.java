package dragdrop.jtree;

import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;

import javax.swing.tree.DefaultTreeModel;

import sqltool.common.MD5Encryption;
import xmlutil.XmlTagName;

import org.xml.sax.*;
import org.xml.sax.helpers.DefaultHandler;


/**
 * Content handler for parsing the XML data for a "DefaultTreeModel"
 * @author wjohnson000
 *
 */
public class TreeXMLHandler extends DefaultHandler {
	private String  passcode     = null;
	private MD5Encryption md5    = null;

	private boolean rootTagOK    = false;
	private String  rootName     = null;
	private String  nodeName     = null;
	private String  className    = null;
	private String  varName      = null;
	private String  charData     = "";

	private List<String>       pathList     = null;
	private Map<String,String> variableMap  = null;
	
	private DefaultTreeModel model  = null;
	
	
	public TreeXMLHandler(String passcode) {
		super();
		this.passcode = passcode;
		md5 = new MD5Encryption();
	}

	/**
	 * Return the tree generated by the process
	 * @return DefaultTreeModel generated from the XML file
	 */
	public DefaultTreeModel getModel() {
		return model;
	}

	/**
	 * Method called by the parser at the beginning of the document.  We don't
	 * need to do anything, but we'll retain it in case we need it in the
	 * future.
	 */
	public void startDocument() throws SAXException {
//		System.out.println("Start Document Processing ...");
	}
	
	/**
	 * Method called by the parser when we reach the end of the document.  We
	 * don't need to do anything, but we'll retain it in case we need it in the
	 * future.
	 */
	public void endDocument() throws SAXException {
//		System.out.println("End Document Processing ...");
//		for (int i=0;  i<paramList.size();  i++) {
//		System.out.println("Param: " + paramList.get(i));
//		}
	}
	
	/**
	 * Method called by the parser when a new element is encountered.  We track
	 * three elements here:
	 *   1) root element (ensure that we don't do anything until this is reached)
	 *   2) "node": pull the name from the attribute list, reset values
	 *   3) "variable": pull the variable name from the attribute list
	 */
	public void startElement(String namespaceURI, String localName,
			String qName, Attributes attr)
			throws SAXException {
		// Don't do anything until we have found the main tag, then create
		// the try with the root node, appropriately named
		if (! rootTagOK) {
			rootTagOK = XmlTagName.TAG_TREE_ROOT.equalsIgnoreCase(localName);
			rootName = getAttrValue(attr, XmlTagName.ATTR_NAME);
			DndTreeNode rootFolder = new DndTreeNode(rootName, null);
			model = new DefaultTreeModel(rootFolder, true);
		} else if (XmlTagName.TAG_NODE.equalsIgnoreCase(localName)) {
			nodeName = getAttrValue(attr, XmlTagName.ATTR_NAME);
			className = null;
			variableMap = new HashMap<String,String>(10);
			pathList = new ArrayList<String>(4);
		} else if (XmlTagName.TAG_VARIABLE.equalsIgnoreCase(localName)) {
			varName = getAttrValue(attr, XmlTagName.ATTR_NAME);
		}
		charData = "";
	}
	
	/**
	 * Method called by the parser when the end of an element is encountered.
	 * We track three elements here:
	 *   1) "node": make sure the folder path exists, create the item and set
	 *      the values for that node after de-crypting any password values
	 *   2) "class": pull the class name from the CDATA
	 *   3) "path-element": pull the folder name from the CDATA
	 *   4) "variable": pull the value from the CDATA
	 */
	public void endElement(String namespaceURI, String localName, String qName)
			throws SAXException {
		// Make sure we found the root element
		if (rootTagOK) {
			if (XmlTagName.TAG_NODE.equalsIgnoreCase(localName)) {
				DndTreeNode folder = (DndTreeNode)model.getRoot();
				for (int i=1;  i<pathList.size();  i++) {
					String pathName = (String)pathList.get(i);
					folder = getChild(folder, pathName);
				}
				try {
					FolderItem item = (FolderItem)Class.forName(className).newInstance();
					item.setValues(variableMap);
					folder.setUserObject(item);
				} catch (Exception ex) {
					System.out.println("Item: " + nodeName + " . " + className + " ... " + ex);
				}
			} else if (XmlTagName.TAG_CLASS.equalsIgnoreCase(localName)) {
				className = charData;
				charData  = "";
			} else if (XmlTagName.TAG_PATH_ELEMENT.equalsIgnoreCase(localName)) {
				pathList.add(charData);
				charData = "";
			} else if (XmlTagName.TAG_VARIABLE.equalsIgnoreCase(localName)) {
				if ("password".equalsIgnoreCase(varName)) {
					try {
						charData = md5.decrypt(passcode, charData);
					} catch (Exception ex) {
						charData = "Unknown";
					}
				}
				variableMap.put(varName, charData);
				charData = "";
			}
		}
	}

	/**
	 * Method that is called by the parser when a <![CDATA[...]]> tag is encountered.
	 * We just need to extract the raw data and save it.
	 */
	public void characters(char[] ch, int start, int length)
			throws SAXException {
		charData += new String(ch, start, length);
	}

	/**
	 * Convenience method for extracting the value of an attribute given its
	 * name
	 */
	private String getAttrValue(Attributes attr, String attrName) {
		String attrValue = "";
		int aCnt = attr.getLength();
		for (int i=0;  i<aCnt;  i++) {
			if (attrName.equalsIgnoreCase(attr.getLocalName(i))) {
				attrValue = attr.getValue(i);
			}
		}
		return attrValue;
	}

	/**
	 * Convenience method for finding -- or creating -- a child folder given
	 * the parent folder and the child's name
	 * 
	 * @param parent parent folder (DndTreeNode)
	 * @param name name of the child
	 * @return child folder, created if not found
	 */
	private DndTreeNode getChild(DndTreeNode parent, String name) {
		DndTreeNode childNode = null;
		for (int i=0;  childNode==null && i<parent.getChildCount();  i++) {
			DndTreeNode aNode = (DndTreeNode)parent.getChildAt(i);
			if (name.equalsIgnoreCase(aNode.label)) {
				childNode = aNode;
			}
		}
		if (childNode == null) {
			childNode = new DndTreeNode(name, null);
			model.insertNodeInto(childNode, parent, parent.getChildCount());
		}
		return childNode;
	}
}
